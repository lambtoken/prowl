diff --git a/assets/sounds/arrow.wav b/assets/sounds/arrow.wav
deleted file mode 100644
index 0d88cf3..0000000
Binary files a/assets/sounds/arrow.wav and /dev/null differ
diff --git a/assets/sounds/clickyclicky.wav b/assets/sounds/clickyclicky.wav
deleted file mode 100644
index bd065ed..0000000
Binary files a/assets/sounds/clickyclicky.wav and /dev/null differ
diff --git a/assets/sprites.xcf b/assets/sprites.xcf
index 63ce86c..42c66e5 100644
Binary files a/assets/sprites.xcf and b/assets/sprites.xcf differ
diff --git a/libs/mold.lua b/libs/mold.lua
index 4eda567..49c193c 100644
--- a/libs/mold.lua
+++ b/libs/mold.lua
@@ -395,7 +395,6 @@ function Box:playAnimation(name, loop)
     loop = loop or false
     
     table.insert(self.animations, self:createAnimation(name, loop))
-    return self
 end
 
 
@@ -2130,27 +2129,6 @@ function QuadBox:resize()
     self:setScale()
 end
 
-function QuadBox:_handleAspectRatio(w, h)
-
-    if self.scaleBy == SCALE_BY.HEIGHT then
-        local ratio = self.origHeight / self.origWidth
-        return h * ratio, h
-
-    elseif self.scaleBy == SCALE_BY.WIDTH then
-        local ratio = self.origHeight / self.origWidth
-        return w, w * ratio
-    end
-
-    return w, h
-end
-
-function QuadBox:setScaleBy(str)
-    assert(type(str) == "string", "Argument must be a string!")
-    -- add a check for SCALE_BY values
-    self.scaleBy = str
-    return self
-end
-
 function QuadBox:draw()
     Box.draw(self) -- Draws background if needed
     love.graphics.setColor(1,1,1,1)
diff --git a/src/generation/items.lua b/src/generation/items.lua
index 8aa1c89..222bfa2 100644
--- a/src/generation/items.lua
+++ b/src/generation/items.lua
@@ -1,6 +1,4 @@
 local RM = require ('src.render.RenderManager'):getInstance()
-local SoundManager = require('src.sound.SoundManager'):getInstance()
-
 -- rarities: common, uncommon, rare, epic, legendary
 
 --                     ▓▓▓▓▓▓      
@@ -456,7 +454,6 @@ local items = {
         passive = {
             description = "Attacks knockback enemies.",
             onAttack = function(matchState, source, target) 
-                print("DOOOOOOOOOOOOOOO ITTTTTTTTTTTTTTTTT")
                 matchState.crowdControlSystem:applyCC(target, "knockback", source)
             end
         },
@@ -471,7 +468,7 @@ local items = {
         passive = {
             description = "Careful, recoil..",
             onAttack = function(matchState, source, target)
-                if target.metadata.type == 'animal' then
+                if source.metadata.type == 'animal' then
                     matchState.crowdControlSystem:applyCC(source, "knockback", target)
                 end
             end
@@ -517,7 +514,6 @@ local items = {
             onStep = function(matchState, source)
                 local nearestEntity = matchState.moveSystem:getNearestEntity(source, 'animal', source.metadata.teamId)
                 if nearestEntity then
-                    SoundManager:playSound("arrow")
                     matchState:newProjectile('arrow', source.position.x, source.position.y, nearestEntity.position.x, nearestEntity.position.y, source.metadata.id)
                 end
             end
@@ -783,6 +779,34 @@ local items = {
         },
         active = {},
     },
+    tire = {
+        name = "tire",
+        type = "health",
+        rarity = "common",
+        stats = {{"increase", "maxHp", 3}},
+        data = {},
+        pattern = {},
+        passive = {},
+        active = {},
+    },
+    box = {
+        name = "box",
+        type = "health",
+        rarity = "common",
+        stats = {{"increase", "maxHp", 5}},
+        data = {},
+        pattern = {
+            {'remove', 'atkPattern', {
+                {1, 1, 1, 1, 1},
+                {1, 0, 0, 0, 1},
+                {1, 0, 0, 0, 1},
+                {1, 0, 0, 0, 1},
+                {1, 1, 1, 1, 1},
+            }}
+        },
+        passive = {},
+        active = {},
+    },
 }
 
 local crownWidth = RM.renderDistanceX + 1
diff --git a/src/generation/mobs.lua b/src/generation/mobs.lua
index f3d3b54..402d196 100644
--- a/src/generation/mobs.lua
+++ b/src/generation/mobs.lua
@@ -793,7 +793,7 @@ local mobs = {
         name = 'crocodile',
         sprite = 'crocodile',
         stats = {
-            atk = 2,
+            atk = 5,
             def = 2,
             maxHp = 5,
             moves = DEFAULT.moves,
diff --git a/src/generation/objects.lua b/src/generation/objects.lua
index ab3c347..75ccc97 100644
--- a/src/generation/objects.lua
+++ b/src/generation/objects.lua
@@ -351,7 +351,7 @@ local objects = {
                 return false
             end,
             onTouched = function(matchState, object, entity)
-                if entity.state.alive then
+                if entity.state.current == "alive" then
                     matchState.combatSystem:hit(entity, 1)
                 end
             end
@@ -372,7 +372,7 @@ local objects = {
         steppable = false,
         passive = {
             onTouched = function(matchState, object, entity)
-                if entity.state.alive then
+                if entity.state.current == "alive" then
                     matchState.combatSystem:hit(entity, 1)
                 end
             end
@@ -539,7 +539,7 @@ local objects = {
                 return false
             end,
             onStep = function(matchState, object)
-                if object.state.alive then
+                if object.state.current == "alive" then
                     local targets = matchState.moveSystem:getTouching(object.position.x, object.position.y, "animal")
                     for index, target in ipairs(targets) do
                         matchState.combatSystem:hit(target, 1)
diff --git a/src/generation/projectiles.lua b/src/generation/projectiles.lua
index 5aad2c6..2739fda 100644
--- a/src/generation/projectiles.lua
+++ b/src/generation/projectiles.lua
@@ -21,8 +21,6 @@ local defaultMove = function(entity, dt)
             local normalizedY = dy / normalIzed
             pos.x = pos.x + normalizedX * speed * dt
             pos.y = pos.y + normalizedY * speed * dt
-            pos.lastStepX = pos.x
-            pos.lastStepY = pos.y
             speed = speed * damping
         end
     end
diff --git a/src/generation/stageMobAmount.lua b/src/generation/stageMobAmount.lua
index 4a72fc4..3663265 100644
--- a/src/generation/stageMobAmount.lua
+++ b/src/generation/stageMobAmount.lua
@@ -1,17 +1,17 @@
 local amounts = {
     {
-        {2, 2},
         {2, 2},
         {2, 3},
         {3, 3},
         {3, 4},
+        {3, 5},
+        {4, 5},
         {4, 5},
-        {5, 6},
     },
     {
-        {5, 6},
-        {5, 7},
-        {5, 7},
+        {6, 7},
+        {6, 8},
+        {7, 8},
         {6, 7},
         {7, 8},
         {8, 9},
diff --git a/src/generation/stageMobLevels.lua b/src/generation/stageMobLevels.lua
index 63f0630..0c9c195 100644
--- a/src/generation/stageMobLevels.lua
+++ b/src/generation/stageMobLevels.lua
@@ -2,19 +2,19 @@ local stageMobLevels = {
     -- Stage 1
     {
         -- Match 1
-        {levelUpChance = 0, negativeChance = 1, minLevel = 2, maxLevel = 2},
+        {levelUpChance = 0, negativeChance = 0.6, minLevel = 2, maxLevel = 2},
         -- Match 2
-        {levelUpChance = 0, negativeChance = 0.8, minLevel = 2, maxLevel = 2},
+        {levelUpChance = 0.1, negativeChance = 0.5, minLevel = 2, maxLevel = 2},
         -- Match 3
-        {levelUpChance = 0, negativeChance = 0.7, minLevel = 2, maxLevel = 2},
+        {levelUpChance = 0.1, negativeChance = 0.4, minLevel = 2, maxLevel = 2},
         -- Match 4
-        {levelUpChance = 0.1, negativeChance = 0.5, minLevel = 2, maxLevel = 3},
+        {levelUpChance = 0.2, negativeChance = 0.4, minLevel = 2, maxLevel = 3},
         -- Match 5
-        {levelUpChance = 0.2, negativeChance = 0.3, minLevel = 2, maxLevel = 3},
+        {levelUpChance = 0.3, negativeChance = 0.3, minLevel = 2, maxLevel = 3},
         -- Match 6
-        {levelUpChance = 0.3, negativeChance = 0.2, minLevel = 2, maxLevel = 4},
+        {levelUpChance = 0.4, negativeChance = 0.2, minLevel = 2, maxLevel = 4},
         -- Match 7 (boss)
-        {levelUpChance = 0.4, negativeChance = 0.1, minLevel = 2, maxLevel = 4},
+        {levelUpChance = 0.5, negativeChance = 0.1, minLevel = 2, maxLevel = 4},
     },
     -- Stage 2  
     {
diff --git a/src/render/components/item_select/item_box.lua b/src/render/components/item_select/item_box.lua
deleted file mode 100644
index 624a23f..0000000
--- a/src/render/components/item_select/item_box.lua
+++ /dev/null
@@ -1,21 +0,0 @@
-local portrait = require "src.render.components.portrait"
-local gs = require("src.state.GameState"):getInstance()
-
-local function item(item_name)
-    
-    local p = portrait(item_name)
-    p.item_name = item_name
-
-    p.onMousePressed = function(self)
-        gs.run:giveItemAndProgress(self.item_name)
-    end
-    
-    p.onMouseEnter = function(self)
-        self:playAnimation("attack")
-    end
-
-    return p
-
-end
-
-return item
\ No newline at end of file
diff --git a/src/render/components/portrait.lua b/src/render/components/portrait.lua
deleted file mode 100644
index f18529b..0000000
--- a/src/render/components/portrait.lua
+++ /dev/null
@@ -1,15 +0,0 @@
-local mold = require "libs.mold"
-local RM = require("src.render.RenderManager"):getInstance()
-local spriteTable = require "src.render.spriteTable"
-
-local function new_portrait(entity_name)
-
-    local p = mold.QuadBox:new(RM.image, spriteTable[entity_name][1] * RM.spriteSize, spriteTable[entity_name][2] * RM.spriteSize, RM.spriteSize, RM.spriteSize)
-    p:setWidth("100px")
-    p:setHeight("100px")
-
-    return p
-
-end
-
-return new_portrait
\ No newline at end of file
diff --git a/src/render/components/stats.lua b/src/render/components/stats.lua
deleted file mode 100644
index ea37c35..0000000
--- a/src/render/components/stats.lua
+++ /dev/null
@@ -1,39 +0,0 @@
-local mold = require "libs.mold"
-local RM = require("src.render.RenderManager"):getInstance()
-local spriteTable = require "src.render.spriteTable"
-
-local function new_stat(stat)
-    local container = mold.Container:new()
-
-    local key = mold.TextBox(stat)
-        :setWidth("50%")
-    local value = mold.TextBox(stat)
-        :setWidth("50%")
-
-    container:addChild(key)
-    container:addChild(value)
-
-    return container
-end
-
-local function new_stats(entity)
-
-    local s = mold.Container:new()
-    
-    local col1 = mold.Container:new()
-    local col2 = mold.Container:new()
-
-    s:setWidth("500px")
-    s:setHeight("500px")
-
-    return s
-
-end
-
--- name
--- hp: 20
--- atk: 2 def: 20
--- crit ls
--- pen luck
-
-return new_stat
\ No newline at end of file
diff --git a/src/render/match/animationData.lua b/src/render/match/animationData.lua
index 02c3fcc..6c2a191 100644
--- a/src/render/match/animationData.lua
+++ b/src/render/match/animationData.lua
@@ -2,8 +2,6 @@ local EventManager = require("src.state.events"):getInstance()
 local RM = require('src.render.RenderManager'):getInstance()
 
 local SWAY_DURATION = 0.7
-local SINE_DURATION = 1.7
-local SINE_RANGE = 0.2
 
 local animations = {
 
@@ -250,6 +248,8 @@ local animations = {
                 to = 2 * math.pi,
                 func = "outQuart"
             },
+
+
         }
     },
 
@@ -287,41 +287,6 @@ local animations = {
             }
         }
     },
-
-    sine_wave = { 
-
-        cancelCategory = "none",
-        loop = false,
-        stackable = true,
-        onFinish = function() end,
-        tweens = {
-            {
-                delay = 0,
-                duration = SINE_DURATION,
-                target = 'rotation',
-                from = 0,
-                to = SINE_RANGE,
-                func = "outSine"
-            },
-            {
-                delay = SINE_DURATION,
-                duration = SINE_DURATION * 2,
-                target = 'rotation',
-                from = SINE_RANGE,
-                to = -SINE_RANGE,
-                func = "inOutSine"
-            },
-            {
-                delay = SINE_DURATION + SINE_DURATION * 2,
-                duration = SINE_DURATION,
-                target = 'rotation',
-                from = -SINE_RANGE,
-                to = 0,
-                func = "inSine"
-            }
-        }
-
-    },
 }
 
 
diff --git a/src/render/ui/match/TextBubbleManager.lua b/src/render/ui/match/TextBubbleManager.lua
index 04a943d..e2d375e 100644
--- a/src/render/ui/match/TextBubbleManager.lua
+++ b/src/render/ui/match/TextBubbleManager.lua
@@ -124,9 +124,9 @@ function TextBubble:newStatusEffect(entity, text, duration)
         id = tostring(os.time()) .. tostring(math.random(1000, 9999)) -- Unique ID for each bubble
     }
 
-    -- print(entity.metadata.id)
-    -- print(entity.metadata.species)
-    -- print(o.entityId)
+    print(entity.metadata.id)
+    print(entity.metadata.species)
+    print(o.entityId)
 
     o.tweenX = tween.new(o.floatDurationX, o, {x = o.bubbleRangeX}, "inOutQuart")
     o.tweenY = tween.new(o.floatDurationY, o, {y = o.bubbleRangeY}, "inOutQuart")
diff --git a/src/run/EntityFactory.lua b/src/run/EntityFactory.lua
index 0660ae9..0a2f806 100644
--- a/src/run/EntityFactory.lua
+++ b/src/run/EntityFactory.lua
@@ -6,7 +6,6 @@ local tablex     = require "libs.batteries.tablex"
 local pretty     = require "libs.batteries.pretty"
 local statusDefaults = require "src.run.ecs.defaults.statusDefaults"
 local gs = require('src.state.GameState'):getInstance()
-local RM = require('src.render.RenderManager'):getInstance()
 
 local EntityFactory = {
     idCounter = 1
@@ -47,16 +46,7 @@ function EntityFactory:applyDefault(entity, comp)
             if entity.stats.level == -1 then
                 for key, value in pairs(entity.stats.base) do
                     if key == "atk" or key == "def" or key == "maxHp" then
-                        
-                        local value = math.floor(value / 2 )
-                        
-                        if key == "def" then
-                            value = math.max(0, value)
-                        else
-                            value = math.max(1, value)  
-                        end
-
-                        entity.stats.base[key] = value
+                        entity.stats.base[key] = math.floor(value / 2 ) 
                     end
                 end
             end
@@ -130,22 +120,14 @@ function EntityFactory:applyDefault(entity, comp)
             end
         end
     elseif comp == "collider" then
-        if entity.metadata.type == "animal" then
-            entity.collider.collisionGroups = {"projectile"}
-        elseif entity.metadata.type == "projectile" then
-            entity.collider.onCollision = function(source, target)
-                local matchState = gs.match
-                if target.state and target.state.current == "dead" then
-                    return
-                end
-                projectileData[entity.metadata.projectileType].onHit(matchState, source, target)
-                source.position.customMove = nil
+        entity.collider.onCollision = function(source, target)
+            local matchState = gs.match
+            if target.state and target.state.current == "dead" then
+                return
             end
-            entity.collider.collisionGroups = {"animal"}
+            projectileData[entity.metadata.projectileType].onHit(matchState, source, target)
+            source.position.customMove = nil
         end
-
-        entity.collider.x = (1 - entity.collider.width) / 2
-        entity.collider.y = (1 - entity.collider.height) / 2
     end
 end
 
@@ -180,7 +162,6 @@ function EntityFactory:createAnimal(species, x, y, level)
     self:applyDefault(entity, 'status')
     self:applyDefault(entity, 'position')
     self:applyDefault(entity, 'metadata')
-    self:applyDefault(entity, 'collider')
 
     return entity
 end
@@ -204,7 +185,6 @@ function EntityFactory:createObject(name, x, y)
     entity.metadata.objectName = name
     self:applyDefault(entity, 'status')
     self:applyDefault(entity, 'position')
-    self:applyDefault(entity, 'collider')
 
     return entity
 end
@@ -256,8 +236,6 @@ end
 function EntityFactory:createProjectile(type, x, y, targetX, targetY, ownerId)
     self:loadComponents()
     
-    print("owner id:", ownerId)
-
     local entity = Concord.entity()
         :give('metadata')
         :give('position', x, y)
@@ -266,7 +244,6 @@ function EntityFactory:createProjectile(type, x, y, targetX, targetY, ownerId)
         :give('collider')
         :give('state')
         :give('shader')
-
     entity.metadata.type = 'projectile'
     entity.metadata.projectileType = type
 
@@ -276,9 +253,8 @@ function EntityFactory:createProjectile(type, x, y, targetX, targetY, ownerId)
     entity.projectile.angle = math.atan2(targetY - y, targetX - x)
    
     self:applyDefault(entity, 'position')
-    self:applyDefault(entity, 'metadata')
     self:applyDefault(entity, 'collider')
-    entity.collider.ignoreIds = ownerId and {ownerId} or {}
+    entity.collider.ignoreIds = {ownerId}
     return entity
 end
 
diff --git a/src/run/InputManager.lua b/src/run/InputManager.lua
index e669017..99894df 100644
--- a/src/run/InputManager.lua
+++ b/src/run/InputManager.lua
@@ -75,7 +75,7 @@ function InputManager:mousepressed(x, y, btn)
         and tileAnimal.state.currentTurnMoves < tileAnimal.stats.current.moves
         and tileAnimal.metadata.teamId == self.match.teamManager.turnTeamId
         and not self.match.moveSystem:isMoving(tileAnimal)
-        and tileAnimal.state.alive 
+        and tileAnimal.state.current == "alive" 
         and currentTeam.agentType == 'player' then        
             self.selectedAnimal = self.match.moveSystem:findByCoordinates(self.hoveredTileX, self.hoveredTileY, 'animal')[1]
             self.selectedAnimal.state.pickedUp = true
diff --git a/src/run/MatchManager.lua b/src/run/MatchManager.lua
index 9255273..962514f 100644
--- a/src/run/MatchManager.lua
+++ b/src/run/MatchManager.lua
@@ -123,7 +123,7 @@ function MatchManager:initialize(node)
                     -- change scene to pick Item Scene
                     
                     if s.instance.winnerId == 1 then
-                        SceneManager:switchScene("itemSelectNew")
+                        SceneManager:switchScene("itemSelect")
                     else
                         gs.run:decreaseHealth()
                         if gs.run.runHealth > 0 then
@@ -298,6 +298,8 @@ function MatchManager:addToTeam(teamId, animal)
         animal:getWorld():removeEntity(animal)
     end
 
+    self.animationSystem:playAnimation(animal, "idle")
+
     self.teamManager:addToTeam(teamId, animal)
     self.ecs:addEntity(animal)
     -- do this somewhere else
@@ -342,6 +344,7 @@ function MatchManager:isSteppable(x, y, entity)
     end
 
     return false
+
 end
 
 
@@ -633,10 +636,10 @@ end
 function MatchManager:preparePlayer()
     for index, animal in ipairs(self.teamManager.teams[1].members) do
         animal.stats.current.hp = animal.stats.current.maxHp
+        animal.state.current = "alive"
         animal.state.currentTurnMoves = 0
         self.animationSystem:removeAll(animal)
         self.moveSystem:removeAll(animal)
-        self.stateSystem:changeState(animal, "idle")
     end
 end
 
diff --git a/src/run/Run.lua b/src/run/Run.lua
index e4c9c0c..7860bdc 100644
--- a/src/run/Run.lua
+++ b/src/run/Run.lua
@@ -2,9 +2,6 @@ local class = require 'libs.middleclass'
 local Stage = require 'src.run.Stage'
 local rng = require 'src.utility.rng'
 local EntityFactory = require "src.run.EntityFactory"
-local gs = require("src.state.GameState"):getInstance()
-local sceneManager = require("src.scene.SceneManager"):getInstance()
-local stageConfig = require "src.run.stageConfig"
 
 local Run = class("Run")
 
@@ -58,19 +55,6 @@ function Run:decreaseHealth()
     self.runHealth = math.max(0, self.runHealth - 1)
 end
 
-function Run:giveItemAndProgress(itemName)
-    gs.match.itemSystem:giveItem(gs.run.team[1], itemName)
-    gs.currentMatchNode.passed = true
-    
-    if self.currentNodeCoords[1] == #stageConfig.format - 1 then
-        self:nextStage()
-    else
-        self.currentNodeCoords = {gs.currentMatchNode.x, gs.currentMatchNode.y}
-    end
-
-    sceneManager:switchScene( "runMap")
-end
-
 function Run:setOutcome()
     if self.runHealth > 0 then
         self.runWon = true
diff --git a/src/run/TeamManager.lua b/src/run/TeamManager.lua
index ce45b3c..5ae920e 100644
--- a/src/run/TeamManager.lua
+++ b/src/run/TeamManager.lua
@@ -24,6 +24,7 @@ function teamManager:new(currentMatch)
             instance = o,
 
             enter = function(s) 
+                s.instance.match.statsSystem:initializeStats()
                 s.instance.states:set_state('stand_by_phase')
             end,
             
@@ -195,7 +196,7 @@ function teamManager:load()
     EventManager = require('src.state.events'):getInstance()
     EventManager:on("checkTeamStatus", function(teamID)
         for index, member in ipairs(self.teams[teamID].members) do
-            if member.state.alive then
+            if member.state.current == "alive" then
                 return
             end
         end
diff --git a/src/run/aiManager.lua b/src/run/aiManager.lua
index af7fac3..7e318b9 100644
--- a/src/run/aiManager.lua
+++ b/src/run/aiManager.lua
@@ -41,8 +41,8 @@ function aiManager:ratingFormula(attacker, attackerX, attackerY, target)
     local targetY = target and target.position.y or averagePosY
 
     local distanceToTarget = math.sqrt((targetX - attackerX) ^ 2 + (targetY - attackerY) ^ 2)
-    --print(distanceToTarget, attacker.metadata.species)
-    --print("avg: ", averagePosX, averagePosY)
+    print(distanceToTarget, attacker.metadata.species)
+    print("avg: ", averagePosX, averagePosY)
     local distanceModifier = 1 / distanceToTarget
     
     local score = target and atk or 1 * (1 + crit) * lsWeight * (1 + ls) * (1 + distanceModifier) + lethalBonus - def / 20
@@ -138,13 +138,13 @@ function aiManager:pickMove(moves, difficulty)
 
         local leftIndex = #moves - math.max(1, math.floor(#moves * 0.1))
         local portion = splitTableByRange(moves, leftIndex, #moves)
-        -- print("moves size: ".. #moves)
-        -- print("portion size: " .. #portion)
-        -- print("left index: ", leftIndex)
+        print("moves size: ".. #moves)
+        print("portion size: " .. #portion)
+        print("left index: ", leftIndex)
 
-        -- for index, value in ipairs(portion) do
-        --     print(value.score, value.x, value.y, value.entity.metadata.species)
-        -- end
+        for index, value in ipairs(portion) do
+            print(value.score, value.x, value.y, value.entity.metadata.species)
+        end
 
         return portion[math.random(#portion)]
         -- return portion[#portion]
@@ -155,7 +155,7 @@ function aiManager:getMove(teamID)
     local allMoves = {}
     
     for _, e in ipairs(self.match.teamManager.teams[teamID].members) do
-        if e.state.alive and self.match.stateSystem:hasActions(e) then
+        if e.state.current == "alive" and self.match.stateSystem:hasActions(e) then
             for _, move in ipairs(self:rateMoves(e)) do
                 table.insert(allMoves, move)
             end
diff --git a/src/run/combat/crowdControlData.lua b/src/run/combat/crowdControlData.lua
index 74d5da4..1e46eb7 100644
--- a/src/run/combat/crowdControlData.lua
+++ b/src/run/combat/crowdControlData.lua
@@ -14,6 +14,15 @@ local data = {
         duration = 1,
         intensity = 1,
         callback = function(matchState, target, source)
+
+            -- acount for if target already knockbacked so multiple kbs stack
+            -- calculate where will that knockback take them and then work from there
+            -- local knockbacks = matchState.moveSystem.getOfType('knockback')
+            -- if #knockbacks > 0 then
+            
+            --     
+
+            -- end
             
             if not target.status or not target.status.current.isDisplaceable then
                 return false
@@ -26,16 +35,19 @@ local data = {
                         
             dx = dx ~= 0 and (dx / math.abs(dx)) or 0
             dy = dy ~= 0 and (dy / math.abs(dy)) or 0
+    
 
-            local knockbackX, knockbackY = ccFunctions.checkPath(matchState, destX, destY, dx, dy, 1)
+            print(target.position.x, target.position.y, destX, destY)
 
-            if target.position.x == knockbackX and target.position.y == knockbackY then
-                return false
-            else
+            if matchState:isSteppable(destX + dx, destY + dy, target) then
+                local knockbackX, knockbackY = ccFunctions.calculateKnockbackPosition(matchState, source.position.x, source.position.y, destX, destY, 1, matchState.terrain)
                 soundManager:playSound("knockback")
                 matchState.moveSystem:move(target, 'knockback', knockbackX, knockbackY)
+                
                 return true
             end
+ 
+            return false
         end,
         animation = {},
         adjective = "knocked"
@@ -72,10 +84,8 @@ local data = {
                 return false
             end
 
-            local destX, destY = matchState.moveSystem:getDestination(target)
-
-            local dx = target.position.x - source.position.x
-            local dy = target.position.y - source.position.y
+            local dx = target.position.x - source.position.lastStepX
+            local dy = target.position.y - source.position.lastStepY
                         
             local ldx, ldy = dy, -dx
             local rdx, rdy = -dy, dx
@@ -85,32 +95,32 @@ local data = {
             rdx = rdx ~= 0 and (rdx / math.abs(rdx)) or 0
             rdy = rdy ~= 0 and (rdy / math.abs(rdy)) or 0
             
+            local destX, destY = matchState.moveSystem:getDestination(target)
+
             local lSteppable = matchState:isSteppable(destX + ldx, destY + ldy, target)
             local rSteppable = matchState:isSteppable(destX + rdx, destY + rdy, target)
             
             if lSteppable and rSteppable then
-                if math.random() > 0.5 then
-                    dx, dy = ldx, ldy
-                else
-                    dx, dy = rdx, rdy
-                end
+                local side = math.random() > 0.5 and "left" or "right"
+                local displaceX, displaceY = ccFunctions.calculatePerpendicularPosition(matchState, source.position.lastStepX, source.position.lastStepY, destX, destY, 1, matchState.terrain, side)
+                soundManager:playSound("displace")
+                matchState.moveSystem:move(target, 'displace', displaceX, displaceY)
+
+                return true
             elseif lSteppable and not rSteppable then
-                dx, dy = ldx, ldy
+                local displaceX, displaceY = ccFunctions.calculatePerpendicularPosition(matchState, source.position.lastStepX, source.position.lastStepY, destX, destY, 1, matchState.terrain, 'left')
+                soundManager:playSound("displace")
+                matchState.moveSystem:move(target, 'displace', displaceX, displaceY)
+
+                return true
             elseif not lSteppable and rSteppable then
-                dx, dy = rdx, rdy
-            else
-                return false
-            end
-            
-            local displaceX, displaceY = ccFunctions.checkPath(matchState, destX, destY, dx, dy, 1)
-            
-            if target.position.x == displaceX and target.position.y == displaceY then
-                return false
-            else
+                local displaceX, displaceY = ccFunctions.calculatePerpendicularPosition(matchState, source.position.lastStepX, source.position.lastStepY, destX, destY, 1, matchState.terrain, 'right')
                 soundManager:playSound("displace")
                 matchState.moveSystem:move(target, 'displace', displaceX, displaceY)
+
                 return true
             end
+
         end,
         animation = {},
         adjective = "displaced"
diff --git a/src/run/combat/crowdControlFunctions.lua b/src/run/combat/crowdControlFunctions.lua
index 719b5c7..9caae1c 100644
--- a/src/run/combat/crowdControlFunctions.lua
+++ b/src/run/combat/crowdControlFunctions.lua
@@ -1,6 +1,68 @@
-local ccFunctions = {
+return {
+    
+    calculateKnockbackPosition = function(matchState, sourceX, sourceY, targetX, targetY, knockbackDistance, terrain) 
+        local dx = targetX - sourceX
+        local dy = targetY - sourceY
+
+        dx = dx ~= 0 and (dx / math.abs(dx)) or 0
+        dy = dy ~= 0 and (dy / math.abs(dy)) or 0
+
+        local finalX, finalY = targetX, targetY
+        
+        for i = 1, knockbackDistance do
+            local nextX = finalX + dx
+            local nextY = finalY + dy
+            
+            if not matchState:isSteppable(nextX, nextY) then
+                break
+            end
+
+            finalX = nextX
+            finalY = nextY
+        end
+
+        return finalX, finalY
+    end,
+
+
+    calculatePullPosition = function(matchState, sourceX, sourceY, targetX, targetY, pullDistance, terrain) 
+        local dx = sourceX - targetX
+        local dy = sourceY - targetY
+
+        dx = dx ~= 0 and (dx / math.abs(dx)) or 0
+        dy = dy ~= 0 and (dy / math.abs(dy)) or 0
+
+        local finalX, finalY = targetX, targetY
+        
+        for i = 1, pullDistance do
+            local nextX = finalX + dx
+            local nextY = finalY + dy
+            
+            if not terrain:isSteppable(nextX, nextY) then
+                break  
+            end
+
+            finalX = nextX
+            finalY = nextY
+        end
+
+        return finalX, finalY
+    end,
+
+
+    calculatePerpendicularPosition = function(matchState, sourceX, sourceY, targetX, targetY, distance, terrain, direction)
+        local dx = targetX - sourceX
+        local dy = targetY - sourceY
+    
+        if direction == "left" then
+            dx, dy = dy, -dx  -- swapping and negating for 90 degrees counter-clockwise
+        elseif direction == "right" then
+            dx, dy = -dy, dx  -- same but for 90 degrees clockwise  
+        end
+    
+        dx = dx ~= 0 and (dx / math.abs(dx)) or 0
+        dy = dy ~= 0 and (dy / math.abs(dy)) or 0
 
-    checkPath = function(matchState, targetX, targetY, dx, dy, distance)
         local finalX, finalY = targetX, targetY
         
         for i = 1, distance do
@@ -17,5 +79,5 @@ local ccFunctions = {
 
         return finalX, finalY
     end
-}
-return ccFunctions
\ No newline at end of file
+    
+}
\ No newline at end of file
diff --git a/src/run/ecs/components/collider.lua b/src/run/ecs/components/collider.lua
index f6f5f09..9473736 100644
--- a/src/run/ecs/components/collider.lua
+++ b/src/run/ecs/components/collider.lua
@@ -4,10 +4,8 @@ local RM = require("src.render.RenderManager"):getInstance()
 local collider = Concord.component("collider", function(component)
     component.collidedWith = {}
     component.collisionGroups = {}
-    component.x = 0
-    component.y = 0
-    component.width = 0.5
-    component.height = 0.5
+    component.width = RM.tileSize
+    component.height = RM.tileSize
     component.disabled = false
     component.ignoreIds = {}
 end)
diff --git a/src/run/ecs/components/state.lua b/src/run/ecs/components/state.lua
index e81fec8..d8adf96 100644
--- a/src/run/ecs/components/state.lua
+++ b/src/run/ecs/components/state.lua
@@ -1,9 +1,7 @@
 local Concord = require("libs.concord")
 
 local state = Concord.component("state", function(component, initialState)
-    component.current = initialState or "idle"
-    component.alive = true
-    component.interactable = true
+    component.current = initialState or "alive"
     component.pickedUp = false
     component.currentTurnMoves = 0
     component.availableActions = 0
diff --git a/src/run/ecs/systems/animationSystem.lua b/src/run/ecs/systems/animationSystem.lua
index 4178768..f848867 100644
--- a/src/run/ecs/systems/animationSystem.lua
+++ b/src/run/ecs/systems/animationSystem.lua
@@ -10,6 +10,9 @@ local animationSystem = Concord.system({pool = {"position", "renderable"}})
 
 
 function animationSystem:init()
+    EventManager:on("enterIdle", function(entity)
+        animationSystem:playAnimation(entity, 'idle')
+    end)
     
     EventManager:on("playAnimation", function(entity, animation)
         animationSystem:playAnimation(entity, animation)
@@ -209,8 +212,6 @@ function animationSystem:removeAll(entity)
         layer.animations = {}
     end
 
-    entity.renderable.animations = {}
-
 end
 
 return animationSystem
\ No newline at end of file
diff --git a/src/run/ecs/systems/collisionSystem.lua b/src/run/ecs/systems/collisionSystem.lua
index 21a3f81..90ca421 100644
--- a/src/run/ecs/systems/collisionSystem.lua
+++ b/src/run/ecs/systems/collisionSystem.lua
@@ -1,5 +1,4 @@
 local Concord = require("libs.concord")
-local RM = require ('src.render.RenderManager'):getInstance()
 local isInTable = require("src.utility.isInTable")
 
 local collisionSystem = Concord.system({pool = {"collider", "position"}})
@@ -27,11 +26,6 @@ function collisionSystem:update()
             or isInTable(colB.ignoreIds, entityA.metadata.id) then
                 goto continue2
             end
-
-            if not isInTable(colA.collisionGroups, entityB.metadata.type)
-            or not isInTable(colB.collisionGroups, entityA.metadata.type) then
-                goto continue2
-            end
             
             if colB.disabled or colA.disabled then
                 goto continue2
@@ -45,26 +39,9 @@ function collisionSystem:update()
                     table.insert(colB.collidedWith, entityA.metadata.id)
 
                     if colA.onCollision then
-                        for index, value in ipairs(colA.ignoreIds) do
-                            print("colA ids: ", value)
-                        end
-                        for index, value in ipairs(colB.ignoreIds) do
-                            print("colB ids: ", value)
-                        end
-                        print(entityA.metadata.id, entityB.metadata.id)
-                        print("collision1")
                         colA.onCollision(entityA, entityB)
                     end
-
                     if colB.onCollision then
-                        for index, value in ipairs(colA.ignoreIds) do
-                            print("colA ids: ", value)
-                        end
-                        for index, value in ipairs(colB.ignoreIds) do
-                            print("colB ids: ", value)
-                        end
-                        print(entityA.metadata.id, entityB.metadata.id)
-                        print("collision2")
                         colB.onCollision(entityB, entityA)
                     end
 
@@ -93,22 +70,10 @@ function collisionSystem:update()
 end
 
 function collisionSystem:checkAABB(posA, colA, posB, colB)
-    local tileSize = RM.tileSize
-
-    local ax = posA.screenX + (colA.x or 0) * tileSize
-    local ay = posA.screenY + (colA.y or 0) * tileSize
-    local aw = (colA.width or 1) * tileSize
-    local ah = (colA.height or 1) * tileSize
-
-    local bx = posB.screenX + (colB.x or 0) * tileSize
-    local by = posB.screenY + (colB.y or 0) * tileSize
-    local bw = (colB.width or 1) * tileSize
-    local bh = (colB.height or 1) * tileSize
-
-    return ax < bx + bw and
-           ax + aw > bx and
-           ay < by + bh and
-           ay + ah > by
+    return posA.screenX < posB.screenX + colB.width and
+           posA.screenX + colA.width > posB.screenX and
+           posA.screenY < posB.screenY + colB.height and
+           posA.screenY + colA.height > posB.screenY
 end
 
 return collisionSystem
\ No newline at end of file
diff --git a/src/run/ecs/systems/combatSystem.lua b/src/run/ecs/systems/combatSystem.lua
index 0a5c80b..4d17226 100644
--- a/src/run/ecs/systems/combatSystem.lua
+++ b/src/run/ecs/systems/combatSystem.lua
@@ -39,8 +39,34 @@ function combatSystem:init()
 
         print(entity.metadata.species)
 
+        local callback = "onStep"
+
         on("onStep", matchState, entity)
         
+        -- if entity.metadata.type == 'animal' then
+        --     local animal = mobData[entity.metadata.species]
+        --     if animal.passive and animal.passive[callback] then
+        --         return animal.passive[callback](matchState, entity)
+        --     end
+        --     if entity.inventory and entity.inventory.items then
+        --         for _, item in ipairs(entity.inventory.items) do
+        --             local item = entity.inventory.items[_]
+        --             local itemDef = itemData[item.name]
+        --             if itemDef.passive and itemDef.passive[callback] then
+        --                 if item.cooldowns and item.cooldowns[callback] and item.cooldowns[callback] > 0 then
+        --                     goto continue
+        --                 end
+        --                 itemDef.passive[callback](matchState, entity, item)
+        --                 return matchState.itemSystem:reduceCooldown(item, callback)
+        --             end
+        --             ::continue::
+        --         end
+        --     end
+        -- end
+
+
+        --on("onStep", matchState, entity)
+
         if not attack then
             return
         end
@@ -59,7 +85,7 @@ function combatSystem:init()
             
                 local isEnemy = entity.metadata.teamId ~= target.metadata.teamId
                 local isTargetable = target.status and target.status.current.isTargetable
-                local isAlive = not (target.state and not target.state.alive)
+                local isAlive = not (target.state and target.state.current ~= "alive")
             
                 if isEnemy and isTargetable and isAlive then
                     if target.stats then
@@ -101,6 +127,16 @@ function combatSystem:init()
             end
 
         end
+
+        -- on step items
+        for _, item in ipairs(entity.inventory.items) do
+            if item.passive and item.passive.onStep then
+                if itemData[item.name].passive and itemData[item.name].passive.onStep then
+                    itemData[item.name].passive.onStep(matchState, entity)
+                end
+            end
+        end
+        
     end)
 
     EventManager:on("onStepAny", function(entity)
@@ -117,7 +153,7 @@ function combatSystem:init()
         
         if entity.metadata.type == 'animal' then
             for _, target in ipairs(targets) do
-                if target == entity or not target.state.alive then 
+                if target == entity or target.state.current ~= "alive" then 
                     goto continue  -- Skip this target instead of returning
                 end
                     
@@ -155,7 +191,7 @@ function combatSystem:init()
             EventManager:emit("onHoveredAny", target)
 
             if target.metadata.type == 'object' then
-                if target == entity or not target.state.alive then
+                if target == entity or target.state.current ~= "alive" then
                     goto continue
                 end
                 local object = objectData[target.metadata.objectName]
@@ -165,7 +201,7 @@ function combatSystem:init()
             end
 
             if target.metadata.type == 'animal' then
-                if target == entity and not target.state.alive then
+                if target == entity and target.state.current ~= "alive" then
                     goto continue
                 end
                 
@@ -340,7 +376,7 @@ function combatSystem:insideAttackPattern(attacker)
     
     local entities = {}
     for _, entity in ipairs(self.pool) do
-        if entity.state.alive then
+        if entity.state.current == "alive" then
             local position = entity.position
             local pattern = attacker.stats.currentPatterns.atkPattern
             
diff --git a/src/run/ecs/systems/moveSystem.lua b/src/run/ecs/systems/moveSystem.lua
index e48cbe5..050f53f 100644
--- a/src/run/ecs/systems/moveSystem.lua
+++ b/src/run/ecs/systems/moveSystem.lua
@@ -119,9 +119,6 @@ function moveSystem:move(entity, type, targetX, targetY, attack, cancelPrev)
     if type == "walk" then
         on("onMove", gs.match, entity)
     end
-    
-    entity.position.attack = attack or entity.position.attack
-    entity.position.step = true
 
     attack = attack or false
 
@@ -159,7 +156,7 @@ function moveSystem:findByCoordinates(x, y, type)
     
     for _, entity in ipairs(self.pool) do
         local typeCondition = not type or entity.metadata.type == type
-        if entity.position.x == x and entity.position.y == y and entity.state and entity.state.alive and typeCondition then
+        if entity.position.x == x and entity.position.y == y and entity.state and entity.state.current == "alive" and typeCondition then
             table.insert(entities, entity)
         end
     end
@@ -260,10 +257,6 @@ end
 
 function moveSystem:handleMoved(entity)
 
-    if not entity.state.alive then
-        return
-    end
-
     if entity.metadata.type == 'animal' then
         if mobData[entity.metadata.species].passive and mobData[entity.metadata.species].passive.onTouched then
             local nearbyEntities = self:getNearbyEntities(entity)
@@ -291,10 +284,6 @@ end
 
 function moveSystem:handleOnStepped(entity)
 
-    if not entity.state.alive then
-        return
-    end
-
     local tileObjects = self:findByCoordinates(entity.position.x, entity.position.y, 'object')
     local tileMarks = self:findByCoordinates(entity.position.x, entity.position.y, 'mark')
 
@@ -331,28 +320,47 @@ function moveSystem:update(dt)
             goto continue
         end
 
+        local forDeletion = {}
+
         local sumX = 0
         local sumY = 0
 
-        for i = #position.moveTweens, 1, -1 do
-            local tween = position.moveTweens[i]
-
+        for _, tween in ipairs(position.moveTweens) do
             tween.tween:update(dt)
             
             if not tween.tween:isComplete() then
                 sumX = sumX + tween.x
                 sumY = sumY + tween.y
-            else    
+            else
+                -- position.prevX = position.lastStepX
+                -- position.prevY = position.lastStepY
+    
                 position.lastStepX = position.lastStepX + tween.x
                 position.lastStepY = position.lastStepY + tween.y
+    
+                self:handleMoved(entity)                
+            
+                self:handleOnStepped(entity)
+    
+                -- search for possible sources
+                -- callback(matchState, target(entity), source)
+    
+                -- should change this later to go of when entity just enters the tile (last hover)
+                events:emit("onStep", entity, tween.attack)
 
-                if position.moveTweens[i].type == 'walk' then
+                table.insert(forDeletion, _)
+            end
+        end
+
+        if #forDeletion > 0 then
+            for i = #forDeletion, 1, -1 do
+                local tweenIndex = forDeletion[i]
+                if position.moveTweens[tweenIndex].type == 'walk' then
                     entity.state.currentTurnMoves = entity.state.currentTurnMoves + 1
                 end
-
-                table.remove(position.moveTweens, i)
+                table.remove(position.moveTweens, tweenIndex)
             end
-        end
+        end        
 
         if #position.moveTweens > 0 then
             position.dirX, position.dirY = calculateDirectionFromTweens(position)
@@ -399,19 +407,6 @@ function moveSystem:update(dt)
 
         position.x = newPosX
         position.y = newPosY
-
-        if #entity.position.moveTweens == 0 and entity.position.step then
-            self:handleMoved(entity)                
-            
-            self:handleOnStepped(entity)
-
-            if entity.state.alive then
-                events:emit("onStep", entity, entity.position.attack)
-            end
-
-            entity.position.step = false
-            entity.position.attack = false
-        end
         
         -- if position.snapTween ~= nil then
         --     print(dt)
@@ -448,7 +443,7 @@ function moveSystem:getAveragePosition(...)
     local sumY = 0
     local n = 0
     for _, entity in ipairs(self.pool) do
-        if entity.metadata and entity.metadata.type == "animal" and entity.state.alive then
+        if entity.metadata and entity.metadata.type == "animal" and entity.state.current == "alive" then
             for i = 1, select("#", ...) do
                 local id = select(i, ...)
                 if entity.metadata.teamId ~= id then
@@ -469,7 +464,7 @@ function moveSystem:getNearestEntity(entity, type, teamID)
 
     for _, otherEntity in ipairs(self.pool) do
 
-        if otherEntity.state and not otherEntity.state.alive then
+        if otherEntity.state and otherEntity.state.current ~= "alive" then
             goto continue
         end
 
diff --git a/src/run/ecs/systems/renderSystem.lua b/src/run/ecs/systems/renderSystem.lua
index b3815ef..702980b 100644
--- a/src/run/ecs/systems/renderSystem.lua
+++ b/src/run/ecs/systems/renderSystem.lua
@@ -193,7 +193,7 @@ function renderSystem:draw()
         end
         if drawColliders and entity.collider then
             love.graphics.setColor(1, 0, 0, 1)
-            love.graphics.rectangle("line", entity.position.screenX + entity.collider.x * RM.tileSize, entity.position.screenY + entity.collider.y * RM.tileSize, entity.collider.width * RM.tileSize, entity.collider.height * RM.tileSize)
+            love.graphics.rectangle("line", entity.position.screenX, entity.position.screenY, entity.collider.width, entity.collider.height)
             love.graphics.setColor(1, 1, 1, 1)
         end
     end
diff --git a/src/run/ecs/systems/stateSystem.lua b/src/run/ecs/systems/stateSystem.lua
index 17ceae4..69e2358 100644
--- a/src/run/ecs/systems/stateSystem.lua
+++ b/src/run/ecs/systems/stateSystem.lua
@@ -48,12 +48,12 @@ end
 
 function stateSystem:onStateEnter(entity, state)
     if state == "idle" then
-        entity.state.alive = true
-        entity.state.interactable = true
-        EventManager:emit('playAnimation', entity, "idle")        
+        if entity.animation then
+            EventManager:emit('enterIdle', entity)
+            EventManager:emit('playAnimation', entity, "idle")
+        end
     elseif state == "dying" then
-        entity.state.alive = false
-        entity.state.interactable = false
+        -- play death sound
         if entity.metadata.type == 'animal' then
             soundManager:playSound('death')
             SceneManager.currentScene.TextBubbleManager:killEntityBubbles(entity)
@@ -63,8 +63,6 @@ function stateSystem:onStateEnter(entity, state)
         end
         
     elseif state == "dead" then
-        entity.state.alive = false
-        entity.state.interactable = false
         if entity.metadata.type == 'animal' then
             EventManager:emit("checkTeamStatus", entity.metadata.teamId)
             EventManager:emit("onDeath", entity)
@@ -101,9 +99,4 @@ function stateSystem:hasMovesLeft(entity)
     return true
 end
 
-return stateSystem
-
--- spawning -- alive
--- idle  -- alive
--- dying -- alive
--- dead -- dead
\ No newline at end of file
+return stateSystem
\ No newline at end of file
diff --git a/src/run/ecs/systems/statsSystem.lua b/src/run/ecs/systems/statsSystem.lua
index 9ae0df1..4d3b57b 100644
--- a/src/run/ecs/systems/statsSystem.lua
+++ b/src/run/ecs/systems/statsSystem.lua
@@ -7,7 +7,7 @@ local extendPattern = require "src.utility.extendPattern"
 local arrayManipulation = require "src.utility.arrayManipulation"
 local removeFromPattern = require "src.utility.removeFromPattern"
 
-local statsSystem = Concord.system({ pool = { "inventory", "stats" } })
+local statsSystem = Concord.system({ pool = { inventory, stats } })
 
 function statsSystem:init()
     EventManager:on("calculateStats", function()
@@ -113,22 +113,9 @@ function statsSystem:calculateStats(preserveHp)
 
         for _, effect in ipairs(patternEffects) do
             local tag = effect[1]
-
-            if tag ~= "swap" then
-                local args = { unpack(effect, 2) }
-                if patternHandlers[tag] then patternHandlers[tag](unpack(args)) end
-                if statHandlers[tag] then statHandlers[tag](unpack(args)) end
-            end
-        end
-
-        for _, effect in ipairs(statEffects) do
-            local tag = effect[1]
-           
-            if tag == "swap" then
-                local args = { unpack(effect, 2) }
-                if patternHandlers[tag] then patternHandlers[tag](unpack(args)) end
-                if statHandlers[tag] then statHandlers[tag](unpack(args)) end
-            end
+            local args = { unpack(effect, 2) }
+            if patternHandlers[tag] then patternHandlers[tag](unpack(args)) end
+            if statHandlers[tag] then statHandlers[tag](unpack(args)) end
         end
 
         ::continue::
diff --git a/src/scene/scenes/animalSelect.lua b/src/scene/scenes/animalSelect.lua
index 2ad99c5..9257837 100644
--- a/src/scene/scenes/animalSelect.lua
+++ b/src/scene/scenes/animalSelect.lua
@@ -50,6 +50,8 @@ function animalSelect:enter()
         
         local lastRow = container.children[#container.children]
 
+        print(#container.children, #lastRow, cols)
+
         if #lastRow.children > cols then
             container:addChild(newRow())
         end
diff --git a/src/scene/scenes/itemSelect.lua b/src/scene/scenes/itemSelect.lua
index 0e6279c..968b003 100644
--- a/src/scene/scenes/itemSelect.lua
+++ b/src/scene/scenes/itemSelect.lua
@@ -32,9 +32,8 @@ function itemSelect:enter()
     
     local randomItems = getRandomItems(math.random(1, 3), nItems)
 
-    randomItems[1] = 'crossbow'
-    -- randomItems[2] = 'racing_flag'
-    -- randomItems[3] = 'mace'
+    randomItems[1] = 'baseball_bat'
+    randomItems[2] = 'mace'
 
     for i = 1, nItems do
         local item = Item:new(randomItems[i])
@@ -44,7 +43,7 @@ function itemSelect:enter()
 
     self:resize()
 
-    SoundManager:playSound('clickyclicky')
+    SoundManager:playSound('arrow')
 end
 
 function itemSelect:update(dt)
diff --git a/src/scene/scenes/itemSelectNew.lua b/src/scene/scenes/itemSelectNew.lua
deleted file mode 100644
index 69ac847..0000000
--- a/src/scene/scenes/itemSelectNew.lua
+++ /dev/null
@@ -1,117 +0,0 @@
-local Scene = require 'src.scene.scene'
-local RM = require ('src.render.RenderManager'):getInstance()
-local tween = require 'libs.tween'
-local Item = require 'src.render.ui.ItemSelectItem'
-local getRandomItems = require 'src.generation.functions.getRandomItems'
-local pretty         = require 'libs.batteries.pretty'
-local checkerShader = love.graphics.newShader(require('src.render.shaders.checker_shader'))
-local SoundManager  = require('src.sound.SoundManager'):getInstance()
-local mold = require "libs.mold"
-local item_box = require "src.render.components.item_select.item_box"
-local portrait = require "src.render.components.portrait"
-
-local gs = require("src.state.GameState"):getInstance()
-
-local itemMargin = 100
-local itemSize = 200
-local nItems = 3
-
-local itemSelect = Scene:new('itemSelectNew')
-
-function itemSelect:enter()
-    self.root = mold.Container:new():setRoot(RM.windowWidth, RM.windowHeight)
-        :setAlignContent("center")
-        :setJustifyContent("center")
-
-    self.item_container = mold.Container:new()
-        :setWidth("70%")
-        :setHeight("30%")
-        :setJustifyContent("space-evenly")
-
-    self.item_container.flexDirection = "row"
-
-    self.root:addChild(self.item_container)
-
-    self.items = {} 
-    
-    local generated_items = getRandomItems(math.random(1, 3), nItems)
-
-    -- randomItems[1] = 'crossbow'
-    -- randomItems[2] = 'racing_flag'
-    -- randomItems[3] = 'mace'
-
-    for _, i in ipairs(generated_items) do
-        local item = item_box(i)
-            :setWidth("20%")
-            :setScaleBy("width")
-        table.insert(self.items, item)
-        self.item_container:addChild(item)
-    end
-
-    self.animal_container = mold.Container:new()
-        :setWidth("70%")
-        :setHeight("30%")
-        :setJustifyContent("space-evenly")
-
-    self.root:addChild(self.animal_container)
-
-    self.current_animal = gs.run.team[1]
-
-    self.animal_portrait = portrait(self.current_animal.metadata.species)
-        :setWidth("20%")
-        :setScaleBy("width")
-        :playAnimation("sine_wave", true)
-
-        
-    -- self.animal_stats = stats(animal)
-        
-    self.animal_container:addChild(self.animal_portrait)
-    -- self.animal_container:addChild(self.animal_stats)
-    -- self.animal_container:addChild(self.animal_pattern)
-    
-    -- self:load_animal(self.current_animal)
-
-    self.root:resize()
-
-    SoundManager:playSound('clickyclicky')
-end
-
-function itemSelect:load_animal(animal)
-
-end
-
-function itemSelect:update(dt)
-    checkerShader:send("time", love.timer.getTime())
-
-    self.root:update(dt)
-end
-
-function itemSelect:draw()
-    love.graphics.setShader(checkerShader)
-    love.graphics.setColor(1, 1, 1, 1)
-    love.graphics.rectangle("fill", 0, 0, RM.windowWidth, RM.windowHeight)
-    love.graphics.setShader()
-
-    self.root:draw()
-end
-
-function itemSelect:mousemoved(x, y)
-    self.root:mouseMoved(x, y)
-end
-
-function itemSelect:mousepressed(x, y, btn)
-    self.root:mousePressed(x, y, btn)
-end
-
-function itemSelect:mousereleased(x, y, btn)
-    self.root:mouseReleased(x, y, btn)
-end
-
-function itemSelect:resize(w, h)
-    self.root:setRoot(w, h)
-    self.root:resize()
-end
-
-return itemSelect
-
--- onClick adds those items to the players first animal in the team
\ No newline at end of file
diff --git a/src/scene/scenes/match.lua b/src/scene/scenes/match.lua
index 349d4d1..fef0797 100644
--- a/src/scene/scenes/match.lua
+++ b/src/scene/scenes/match.lua
@@ -36,7 +36,10 @@ function match:enter()
         --self.match:addToTeam(1, self.match:newAnimal("bear", 4, 4, 1))
     end
 
-    -- self.match.itemSystem:giveItem(gs.run.team[1], "gear")
+    -- self.match.itemSystem:giveItem(gs.run.team[1], "revolver")
+
+    self.match:preparePlayer()
+    self.match:positionPlayer()
 
     self.turnTracker = turnTracker:new()
     self.turnTracker:load(self.match.teamManager)
@@ -97,8 +100,7 @@ function match:enter()
     self.match:generateFlowers()
     --self.match:generateMarks()
 
-    self.match:preparePlayer()
-    self.match:positionPlayer()
+
 
     self.hearts = Hearts:new(gs.run.team[1])
 
diff --git a/src/sound/soundTable.lua b/src/sound/soundTable.lua
index b0fe1dc..b0e86a7 100644
--- a/src/sound/soundTable.lua
+++ b/src/sound/soundTable.lua
@@ -9,7 +9,6 @@ local soundTable = {
     bear_trap = {type = 'effect', file = 'bear_trap.wav'},
     mouse_trap = {type = 'effect', file = 'mouse_trap.wav'},
     explosion = {type = 'effect', file = 'explosion.wav', volume = 0.5},
-    arrow = {type = 'effect', file = 'arrow.wav', volume = 0.5},
     hiss = {type = 'effect', file = 'hiss.wav', volume = 1},
     bite = {type = 'effect', file = 'bite3.wav'},
     heal = {type = 'heal', file = 'heal.wav'},
@@ -26,7 +25,6 @@ local soundTable = {
     click10 = {type = 'click', file = 'click10.wav', volume = 0.5},
     click11 = {type = 'click', file = 'click11.wav', volume = 0.8},
     click12 = {type = 'click', file = 'click12.wav'},
-    clickyclicky = {type = 'click', file = 'clickyclicky.wav'},
 
     softclick = {type = 'click', file = 'softclick.wav', volume = 0.7},
     softclick2 = {type = 'click', file = 'softclick2.wav', volume = 0.7},
@@ -36,7 +34,7 @@ local soundTable = {
     displace = {type = 'displace', file = 'displace.wav', volume = 1},
     victory = {type = 'ui', file = 'victory.wav', volume = 1},
     loss = {type = 'ui', file = 'slowmo.wav', volume = 0.6},
-    --arrow = {type = 'effect', file = 'oawn.wav', volume = 1},
+    arrow = {type = 'effect', file = 'oawn.wav', volume = 1},
     miss = {type = 'effect', file = 'miss.wav', volume = 0.6},
 }
 
